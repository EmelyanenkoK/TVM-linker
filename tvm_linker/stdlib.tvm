	.internal-alias :main_external,     -1
	.internal-alias :main_internal,     0
	.internal-alias :general_purpose,   1
	.internal-alias :authenticate,      2
	.internal-alias :parse_msg,         3
    .internal-alias :parse_internal_msg, 4
    .internal-alias :init_stack,        5
    .internal-alias :cleanup_stack,     6

    .global-base        0
    .persistent-base    1000000

    .selector
    ; s0 - func_id
    ; s1.. - other data
    SETCP0
    PUSHREFSLICE        ; dictionary of methods in first reference
    OVER
    NEQINT 1
    PUSHCONT {          ; if func_id negative or zero - direct call to method
        PUSHINT 32
        DICTIGETJMP     ; execute method and return
    }
    PUSHCONT {          ; get dictionary with methods
        PUSHINT 32
        DICTIGET
        THROWIFNOT 52   ; no dictionary of methods
        PUSHINT 32
        DICTUGETJMP     ; execute method and return
        THROW 51
    }
    IFELSE

    .internal   :authenticate
    ;ref0 must contains auth dictionary
    ;args: 
    ;   s0 - body slice
    ;ret: 
    ;   s0 - body slice (modified: without ref0)
    ;throws exception if ABI version is unsupported
    ;throws exception if auth flag is not found in authentication dictionary.
    ;throws exception if signature is invalid

    DUP
    PUSHINT 40          ;preload ABI ver and func_id in separate slice
    PLDSLICEX
    LDU 8               ;load ABI version
    LDU 32              ;load func id
    ENDS
    SWAP
    THROWIF 55
    PUSHREFSLICE
    DUP
    SEMPTY
    IFRET
    PUSHINT 32          ;key len in auth dictionary
    DICTUGET            ;load method's flag 
    THROWIFNOT 41       ;not found exception
    PLDU 1
    PUSHCONT {
        DUP
        SREMPTY         ;body must have reference, if not - throw exception
        THROWIF 40      ;access denied exception
        LDREFRTOS       ;detach signature slice
        OVER
        HASHSU
        SWAP    
        PUSHROOT        ;load persistent data
        CTOS            
        LDU 256         ;load public key
        DROP            ;drop remaining data slice
        CHKSIGNU
        THROWIFNOT 40   ;access denied exception
    }
    IF

    .internal   :init_stack
    PUSH c5
    CTOS LDREFRTOS NIP
    PUSHINT $global-base$
    
    PUSHINT $persistent-base$
    ADDCONST 8
    PUSHROOT
    CTOS
    PUSHINT 64
    DICTIGET
    THROWIFNOT 100 ;global data dictionary is invalid
    
    PUSHINT 64
    DICTISET
    NEWC STSLICE ENDC
    POP c5

    .internal :cleanup_stack
    PUSHINT $global-base$
    PUSH c5 CTOS
    PUSHINT 64
    DICTIGET
    THROWIFNOT 100 ;global data dictionary is invalid
    NEWC STSLICE ENDC
    NEWC STREF ENDC
    POP c5

    .internal   :main_external
    ; s0 - msg body: slice
    ; s1 - msg: cell
    ; s2 - gram balance of msg: int
    ; s3 - gram balance of contract: int

    ;call signature checker (can throw exception if signature is invalid)
    CALL $:authenticate$ ;assume that function returns nothing
    
    ;call msg parser
    PUSH s1     ;push msg cell on top
    CALL $:parse_msg$    ;assume thar parser returns slice - dictionary with msg fields

    ;initializes global data dictionary in c5
    CALL $:init_stack$
    
    SWAP
    ;parse ABI version (1 byte) and load function id (4 bytes)
    LDU 8       ;load ABI version
    SWAP  
    THROWIF 55  ; only version 0 is supported now
    LDU 32      ;load func id
    SWAP
    CALL 1      ;public method call

    CALL $:cleanup_stack$


    .internal   :main_internal
    ; s0 - msg body: slice
    ; s1 - msg: cell
    ; s2 - gram balance of msg: int
    ; s3 - gram balance of contract: int
    
    ;call msg parser
    PUSH s1     ;push msg cell on top
    CALL $:parse_internal_msg$    ;assume thar parser returns slice - dictionary with msg fields
    
    ;initializes global data dictionary in c5
    CALL $:init_stack$

    POP s2
    DUP
    SDEMPTY
    IFRET
    ;parse ABI version (1 byte) and load function id (4 bytes)
    LDU 8       ;load ABI version
    SWAP  
    THROWIF 55  ; only version 0 is supported now
    LDU 32      ;load func id
    SWAP
    CALL 1      ;public method call 

    CALL $:cleanup_stack$

    .internal   :parse_msg
    CTOS        ;TODO: use parser from contract_api library

    .internal   :parse_internal_msg
    CTOS
