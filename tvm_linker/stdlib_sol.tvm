	.internal-alias :main_external,     -1
	.internal-alias :main_internal,     0
	.internal-alias :general_purpose,   1

    .selector
    ; s0 - func_id
    ; s1.. - other data
    SETCP0
	ACCEPT
    PUSHREFSLICE        ; dictionary of methods in first reference
    OVER
    NEQINT 1
    PUSHCONT {          ; if func_id negative or zero - direct call to method
        PUSHINT 32
        DICTIGETJMP     ; execute method and return
    }
    PUSHCONT {          ; get dictionary with methods
        PUSHINT 32
        DICTIGET
        THROWIFNOT 52   ; no dictionary of methods
        PUSHINT 32
        DICTUGETJMP     ; execute method and return
        THROW 51
    }
    IFELSE

	.globl	parse_smartcontractinfo
	.type	parse_smartcontractinfo, @function
	;; stack=0
	LOGSTR parse_continfo
	PUSH c5
	CTOS
	LDREFRTOS
	NIP ; drop rest of the cell
	PUSHINT 32
	SDSKIPFIRST ; skip actions and msgs_sent field
	LDU 32 ; put unixtime field on stack
	LDU 64 ; put block_lt field on stack
	LDU 64 ; put trans_lt field on stack
	LDU 256 ; put rand_seed field on stack
	LDU 16 ; put balance_remaining field on stack
	LDDICT
	NIP ; skip ExtraCurrencyCollection dict
	; parse MsgAddressInt
	PUSHINT 11 
	SDSKIPFIRST ; skip anycast: + workchain_id
	LDU 256 ; put address on stack
	DROP ; drop rest of c5 slice
	; s0 - address
	; s1 - balance
	; s2 - rand_seed
	; s3 - trans_lt
	; s4 - block_lt
	; s5 - unixtime
	RET

	.globl		get_address
	.type		get_address, @function
	;; stack=0
	PUSHINT 4
	PUSH c5
	CTOS
	LDREF
	NIP
	LDDICT
	DROP
	PUSHINT 256
	DICTUGET
	DROP
	LDU 256
	DROP ; drop slice itself
	RET
	
	.globl		get_balance
	.type		get_balance, @function
	;; stack=0
	PUSHINT 5
	PUSH c5
	CTOS
	LDREF
	NIP
	LDDICT
	DROP
	PUSHINT 256
	DICTUGET
	DROP
	LDU 16
	DROP ; drop slice itself
	RET
	
	.globl		get_rand_seed
	.type		get_rand_seed, @function
	;; stack=0
	PUSHINT 6
	PUSH c5
	CTOS
	LDREF
	NIP
	LDDICT
	DROP
	PUSHINT 256
	DICTUGET
	DROP
	LDU 256
	DROP ; drop slice itself
	RET
	
	.globl		get_trans_lt
	.type		get_trans_lt, @function
	;; stack=0
	PUSHINT 7
	PUSH c5
	CTOS
	LDREF
	NIP
	LDDICT
	DROP
	PUSHINT 256
	DICTUGET
	DROP
	LDU 64
	DROP ; drop slice itself
	RET
	
	.globl		get_block_lt
	.type		get_block_lt, @function
	;; stack=0
	PUSHINT 8
	PUSH c5
	CTOS
	LDREF
	NIP
	LDDICT
	DROP
	PUSHINT 256
	DICTUGET
	DROP
	LDU 64
	DROP ; drop slice itself
	RET
	
	.globl		get_unixtime
	.type		get_unixtime, @function
	;; stack=0
	PUSHINT 9
	PUSH c5
	CTOS
	LDREF
	NIP
	LDDICT
	DROP
	PUSHINT 256
	DICTUGET
	DROP
	LDU 32
	DROP ; drop slice itself
	RET

    .globl	get_msg_pubkey
	.type	get_msg_pubkey, @function
	; s0 - msg body: slice
	; Returns 0 if message is not signed
	; Returns sender's pubkey if signature is valid
	; Throws exception 40 if signature is invalid
	DUP
	LOGSTR get_msg_pubkey
	SREMPTY
	PUSHCONT {
		DROP
		PUSHINT 0
	}
	PUSHCONT {
		;;;; Checks the signature of a given message and returns sender's public key
		;;;; Throws exception 40 if signature is invalid
		
		; stack: msg
		ZERO SWAP
		; stack: 0 msg
		LDREFRTOS
		; stack: 0 msg' slice:sign+pubKey
		DUP
		; stack: 0 msg' slice:sign+pubKey slice:sign+pubKey
		PUSHINT 512
		SDSKIPFIRST
		LDU 256
		DROP
		; stack: 0 msg' slice:sign+pubKey pubKey
		DUP
		; stack: 0 msg' slice:sign+pubKey pubKey pubKey
		POP s4
		; stack: pubKey msg' slice:sign+pubKey pubKey
		ROT
		; stack: pubKey slice:sign+pubKey pubKey msg' 
		HASHSU
		; stack: pubKey slice:sign+pubKey pubKey msg-hash
		ROTREV
		; stack: pubKey msg-hash slice:sign+pubKey pubKey
		CHKSIGNU
		THROWIFNOT 40
		; stack: pubKey
	}
	IFELSE
	RET
	
	.internal   :main_external
	; s0 - msg body: slice
	; s1 - msg: cell
	; s2 - gram balance of msg: int
	; s3 - gram balance of contract: int
	
	PUSH s3
	PUSH s3
	; s0 - gram balance of msg: int
	; s1 - gram balance of contract: int
	; s2 - msg body: slice
	; s3 - msg: cell
	; s4 - gram balance of msg: int
	; s5 - gram balance of contract: int
	
	PUSH s3
	PUSHINT $get_src_addr$
	CALL 1
	POP s4
	XCHG s2, s3
	XCHG s1, s2
	XCHG s0, s1
	; s0 - addr
	; s1 - gram balance of msg: int
	; s2 - gram balance of contract: int
	; s3 - msg body: slice
	; s4 - gram balance of msg: int
	; s5 - gram balance of contract: int
	
	PUSH s3
	PUSHINT $get_msg_pubkey$
	CALL 1
	; s0 - signature
	; s1 - addr
	; s2 - gram balance of msg: int
	; s3 - gram balance of contract: int
	; s4 - msg body: slice
	; s5 - gram balance of msg: int
	; s6 - gram balance of contract: int
	
	PUSHINT $store_signature$
	CALL 1
	NIP
	NIP
	
	; s0 - msg body: slice
	
	; check if message is empty
	DUP
	SEMPTY
	PUSHCONT {
		DROP
		NEWDICT
		NEWC STSLICE ENDC
		POPROOT
		RET
	}
	IFJMP
    
    ;parse ABI version (1 byte) and load function id (4 bytes)
    LDU 8       ;load ABI version
    SWAP  
    THROWIF 55  ; only version 0 is supported now
    LDU 32      ;load func id
    SWAP
    CALL 1      ;public method call


	.globl		get_pubkey
	.type		get_pubkey, @function
	;; stack=0
	PUSHINT 0
	PUSH c5
	CTOS
	LDREF
	NIP
	LDDICT
	DROP
	PUSHINT 256
	DICTUGET
	DROP
	LDU 256
	DROP ; drop slice itself
	RET

	.globl		get_msg_sender
	.type		get_msg_sender, @function
	;; stack=0
	PUSHINT 1
	PUSH c5
	CTOS
	LDREF
	NIP
	LDDICT
	DROP
	PUSHINT 256
	DICTUGET
	DROP
	LDU 256
	DROP ; drop slice itself
	RET
	
	.globl		get_msg_balance
	.type		get_msg_balance, @function
	;; stack=0
	PUSHINT 2
	PUSH c5
	CTOS
	LDREF
	NIP
	LDDICT
	DROP
	PUSHINT 256
	DICTUGET
	DROP
	LDU 256
	DROP ; drop slice itself
	RET
	
	.globl		get_contract_balance
	.type		get_contract_balance, @function
	;; stack=0
	PUSHINT 3
	PUSH c5
	CTOS
	LDREF
	NIP
	LDDICT
	DROP
	PUSHINT 256
	DICTUGET
	DROP
	LDU 256
	DROP ; drop slice itself
	RET

	.globl		get_src_addr
	.type		get_src_addr, @function
	; s0 - msg: cell
	CTOS
	LDU 1
	SWAP
	PUSHCONT {
		DROP
		PUSHINT 0
		RET
	}
	IFJMP
	
	PUSHINT 3
	SDSKIPFIRST ; skip ihr_disabled + bounce + bounced
	
	;; here we parse src : MsgIntAddress
	
	PUSHINT 11
	SDSKIPFIRST ; skip anycast: + workchain_id
	LDU 256
	DROP ; drop slice itself
	RET


	.globl		store_signature
	.type		store_signature, @function
	; stack: sign
	
	PUSH c5
	CTOS
	LDREFRTOS
;	LDREF	;; not working by some reason
	NIP
	
	; stack: sign SmartContractInfo(SLICE)
	NEWC
	STSLICE
	ENDC

	; stack: sign SmartContractInfo(CELL)
	NEWC
	; stack: sign SmartContractInfo b
	STREF
	; stack: sign b' in dict for key 0
	SWAP
	NEWC STU 256 ENDC CTOS
	PUSHINT 0
	NEWDICT
	PUSHINT 256
	DICTUSET
	; stack: src addr b'' in dict for key 1
	ROT
	NEWC STU 256 ENDC CTOS
	PUSHINT 1
	PUSH s2
	PUSHINT 256
	DICTUSET
	NIP
	; stack: msg balance b''' in dict for key 2
	ROT
	NEWC STU 256 ENDC CTOS
	PUSHINT 2
	PUSH s2
	PUSHINT 256
	DICTUSET
	NIP
	; stack: gram balance of contract b'''' in dict for key 3
	ROT
	NEWC STU 256 ENDC CTOS
	PUSHINT 3
	PUSH s2
	PUSHINT 256
	DICTUSET
	NIP
	PUSHINT $parse_smartcontractinfo$
	CALL 1 ; get additional values from smartcontractinfo
	; s0 - address
	; s1 - balance
	; s2 - rand_seed
	; s3 - trans_lt
	; s4 - block_lt
	; s5 - unixtime
	; s6 - dict
	; put address into dict for key 4
	NEWC STU 256 ENDC CTOS
	PUSHINT 4
	PUSH s7
	PUSHINT 256
	DICTUSET
	; put balance into dict for key 5
	SWAP
	NEWC STU 16 ENDC CTOS
	PUSHINT 5
	PUSH s2
	PUSHINT 256
	DICTUSET
	NIP
	; put rand_seed into dict for key 6
	SWAP
	NEWC STU 256 ENDC CTOS
	PUSHINT 6
	PUSH s2
	PUSHINT 256
	DICTUSET
	NIP
	; put trans_lt into dict for key 7
	SWAP
	NEWC STU 64 ENDC CTOS
	PUSHINT 7
	PUSH s2
	PUSHINT 256
	DICTUSET
	NIP
	; put block_lt into dict for key 8
	SWAP
	NEWC STU 64 ENDC CTOS
	PUSHINT 8
	PUSH s2
	PUSHINT 256
	DICTUSET
	NIP
	; put unixtime into dict for key 9
	SWAP
	NEWC STU 32 ENDC CTOS
	PUSHINT 9
	PUSH s2
	PUSHINT 256
	DICTUSET
	NIP
	NIP ; drop old dict which was at s6 at start of adding smartcontractinfo
	; stack: dict with values
	SWAP
	STDICT
	ENDC
	POP c5
	RET

    .internal   :main_internal
    ; s0 - msg body: slice
    ; s1 - msg: cell
    ; s2 - gram balance of msg: int
    ; s3 - gram balance of contract: int

	PUSH s3
	PUSH s3
	; s0 - gram balance of msg: int
	; s1 - gram balance of contract: int
	; s2 - msg body: slice
	; s3 - msg: cell
	; s4 - gram balance of msg: int
	; s5 - gram balance of contract: int
	
	PUSH s3
	PUSHINT $get_src_addr$
	CALL 1
	POP s4
	XCHG s2, s3
	XCHG s1, s2
	XCHG s0, s1
	; s0 - addr
	; s1 - gram balance of msg: int
	; s2 - gram balance of contract: int
	; s3 - msg body: slice
	; s4 - gram balance of msg: int
	; s5 - gram balance of contract: int
	
	PUSHINT 0 ; put 0 instead of signature
	; s0 - 0 as signature
	; s1 - addr
	; s2 - gram balance of msg: int
	; s3 - gram balance of contract: int
	; s4 - msg body: slice
	; s5 - gram balance of msg: int
	; s6 - gram balance of contract: int
	
	PUSHINT $store_signature$
	CALL 1
	NIP
	NIP
	
    ; s0 - msg body: slice
	
	; protection against empty message
	DUP
	SEMPTY
	IFRET
    
    ;parse ABI version (1 byte) and load function id (4 bytes)
    LDU 8       ;load ABI version
    SWAP  
    THROWIF 55  ; only version 0 is supported now
    LDU 32      ;load func id
    SWAP
    CALL 1      ;public method call

    RET

	.globl	send_grams
	.type	send_grams, @function
		;args:
		;; s0 - body: slice
		;; s1 - dst account address: integer
		;; s2 - transfer grams value: integer
		;ret: none
		
		PUSHINT 0	;; next msg logical time
		PUSH s1	;; body: slice
		PUSH s3	;; dst account address: integer
		PUSH s5	;; transfer grams value: integer
		PUSHINT $send_int_msg$
		CALL 1
		
		POP s1
		POP s1
		POP s1
		RET

	.globl	send_int_msg_2
	.type	send_int_msg_2, @function
		;args: 
		; s0 - body: slice
		; s1 - dst account address: integer
		;ret: none
		
		PUSHINT 0	;; next msg logical time
		PUSH s1		;; body: slice
		PUSH s3		;; dst account address: integer
		PUSHINT 10000	;; transfer grams value: integer
		
		PUSHINT $send_int_msg$
;		RET
		CALL 1
		
		POP s1
		POP s1
		RET
	
	.globl	send_int_msg
	.type	send_int_msg, @function
	;; taken from TON-Wallet
			;args: 
			; s0 - transfer grams value: integer
			; s1 - dst account address: integer
			; s2 - body: slice
			; s3 - next msg logical time
			;ret: none

			SWAP
					
			;args: s0 - address: integer u256
			;ret: s0 - slice
				NEWC
				;tag$10 + $0 (anycast is NULL) + $00000000 (workchain_id 0i8)
				STSLICECONST x801_
;				STSLICECONST x9FF_
				STU 256
				ENDC
				CTOS


					; load SmartContractInfo 
					PUSHCTR c5
					CTOS
					LDREFRTOS
					NIP
					
					PUSHINT 64 ; 32 + 16 + 16
					SDSKIPFIRST ; skip tag + actions + msgs_sent
					LDU 32      ; unixtime
					PUSHINT 128
					SDSKIPFIRST ; skip block_lt + trans_lt 
					PUSH s5     ; push msg lt
					SWAP        
					PUSHINT 256
					SDSKIPFIRST ; skip rand_seed

					
				PUSHCONT {
				;parses CurrencyCollection type
				;args: s0 - slice
				;ret:
				;   s0 - remaining slice
				;   s1 - grams: slice
					
			PUSHCONT {
				;parses Grams type (VarInteger 16)
				;args: s0 - slice
				; ret:
				;   s0 - remaining slice
				;   s1 - grams: slice
				;starts with 4bit length field 
				LDU 4
				SWAP
				DUP
				; load 'value' len*8 bits if len != 0, otherwise 0
				PUSHCONT {
					PUSHINT 8
					MUL
					LDUX
					SWAP
				}
				PUSHCONT {
					DROP
					PUSHINT 0
				}
				IFELSE
				;restore it as u128 integer 
				NEWC
				STU 128
				ENDC
				CTOS
				SWAP
			}

					CALLX
					; skip HashmapE with currencies.
					SKIPDICT
				}
				
					CALLX

					NIP
					; s0 - myself: MsgAddressInt (slice) 
					; s1 - trans_lt: u64
					; s2 - tr unixtime: u32
					; s3 - transfer grams value: integer
					; s4 - dst account address: integer
					; s5 - body: slice
					ROTREV
					PUSHINT 0   ; fwd_fee
					PUSHINT 0   ; ihr_fee
					BLKSWAP 3, 4

					;stack trace:
					; s0 - myself: MsgAddressInt (slice) 
					; s1 - dst account address: integer
					; s2 - transfer grams value: integer
					; s3 - ihr_fee
					; s4 - fwd_fee
					; s5 - trans_lt: u64
					; s6 - tr unixtime: u32
					; s7 - body: slice

					PUSHINT 1   ; bounce flag
					PUSHINT 0   ; reset ihr_disabled flag
					
				PUSHCONT {
				; build internal outbound message
				; s0 - ihr_disabled: integer (1 or 0)
				; s1 - bounce: integer (1 or 0)
				; s2 - src address : slice (MsgAddressInt)
				; s3 - dst address : slice (MsgAddressInt)
				; s4 - value: integer
				; s5 - ihr_fee: integer
				; s6 - fwd_fee: integer
				; s7 - logical time: integer (u64)
				; s8 - unixtime: integer (u32)
				; s9 - body: slice
				; returns: msg: cell

					NEWC
					STSLICECONST 0 ; int_msg_info$0
					STU 1 ; ihr_disabled
					STU 1 ; bounce
					STSLICECONST 0 ; bounced
					STSLICE
					STSLICE
					SWAP
					
				;s0 - value: integer (u64)
				;s1 - builder
				
				;s0 - value: integer (u64)
				;s1 - builder
				DUP
				PUSHCONT {
					DUP
					UBITSIZE     ; bit count used by integer 
					PUSHINT 8   
					DIVC        ; calculate number of bytes needed for integer
					DUP
					PUSH s3     ; push builder
					STU 4       ; store len (bytes)
					SWAP        
					PUSHINT 8   
					MUL         ; calculate bits for integer (rounded to byte)
					STUX        ; store value
					NIP
				}
				PUSHCONT {
					DROP
					PUSHINT 0
					STUR 4
				}
				IFELSE

				STSLICECONST 0
				
					SWAP
					
				;s0 - value: integer (u64)
				;s1 - builder
				DUP
				PUSHCONT {
					DUP
					UBITSIZE     ; bit count used by integer 
					PUSHINT 8   
					DIVC        ; calculate number of bytes needed for integer
					DUP
					PUSH s3     ; push builder
					STU 4       ; store len (bytes)
					SWAP        
					PUSHINT 8   
					MUL         ; calculate bits for integer (rounded to byte)
					STUX        ; store value
					NIP
				}
				PUSHCONT {
					DROP
					PUSHINT 0
					STUR 4
				}
				IFELSE
			 ; store ihr_fee
					SWAP
					
				;s0 - value: integer (u64)
				;s1 - builder
				DUP
				PUSHCONT {
					DUP
					UBITSIZE     ; bit count used by integer 
					PUSHINT 8   
					DIVC        ; calculate number of bytes needed for integer
					DUP
					PUSH s3     ; push builder
					STU 4       ; store len (bytes)
					SWAP        
					PUSHINT 8   
					MUL         ; calculate bits for integer (rounded to byte)
					STUX        ; store value
					NIP
				}
				PUSHCONT {
					DROP
					PUSHINT 0
					STUR 4
				}
				IFELSE
			 ; store fwd_fee
					STU 64        ; store logical time
					STU 32        ; store unixtime
					
					STSLICECONST 0 ; (Maybe StateInit) to 0bit
					STSLICECONST 0 ; (body Either) to left$0
					STSLICE       ; store body
					ENDC
				}
				
					CALLX
					PUSHINT 0
					SENDRAWMSG
					
				PUSHINT 123
				DROP
				RET
				