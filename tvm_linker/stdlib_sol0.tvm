	.internal-alias :main_external,     -1
	.internal-alias :main_internal,     0
	.internal-alias :general_purpose,   1
	.internal-alias :parse_grams,       2

	.selector
	; s0 - func_id
	; s1.. - other data
	SETCP0
	ACCEPT
	PUSHREFSLICE        ; dictionary of methods in first reference
	PLDDICT
	OVER
	NEQINT 1
	PUSHCONT {          ; if func_id negative or zero - direct call to method
		PUSHINT 32
		PRINTSTR selector_jmp_0
		DICTIGETJMP     ; execute method and return
	}
	PUSHCONT {          ; get dictionary with methods
		PUSHINT 32
        DICTIGETREF
		THROWIFNOT 52   ; no dictionary of methods
		PUSHINT 32
		PRINTSTR selector_jmp
		DICTUGETJMP     ; execute method and return
		THROW 51
	}
	IFELSE

	.internal   :parse_grams
	;parses Grams type (VarInteger 16)
	;args: s0 - slice
	; ret:
	;   s0 - remaining slice
	;   s1 - grams: slice
	;starts with 4bit length field
	LDU 4
	SWAP
	DUP
	; load 'value' len*8 bits if len != 0, otherwise 0
	PUSHCONT {
		PUSHINT 8
		MUL
		LDUX
		SWAP
	}
	PUSHCONT {
		DROP
		PUSHINT 0
	}
	IFELSE
	;restore it as u128 integer
	NEWC
	STU 128
	ENDC
	CTOS
	SWAP


	.globl		change_array_length
	.type		change_array_length, @function
	;; s0 - new len
	;; s1 - array
	;; s2 - 0 slice size of numBits
	PRINTSTR change_arr_len
	PUSH s1
	PUSHINT 32
	DICTUMAX
	PUSHCONT { POP s1 INC }
	PUSHCONT { PUSHINT 0 }
	IFELSE
	;; s0 - old len
	;; s1 - new len
	;; s2 - array
	;; s3 - 0 slice size of numBits
	DUP
	PUSH s2
	;; >=
	GEQ
	PUSHCONT {
		PUSHCONT {
			;; old len
			DUP
			;; new len
			PUSH s2
			;; >
			GREATER
			NOT DUP IFRET DROP
			;; old len
			DUP
			DEC
			;; assign old len
			NIP
			DUP
			PUSH s3
			PUSHINT 32
			DICTUDEL
			DROP
			POP s3
			FALSE
		}
		UNTIL
		; while end
	}
	PUSHCONT {
		; TODO: Fix an issue#2 with arr.length
		PUSH s3
		ISNULL
		PUSHCONT {
			PUSH s3
			PUSH s2
			DEC
			PUSH s4
			PUSHINT 32
			DICTUSET
			POP s3
		}
		IFNOT
	}
	IFELSE
	BLKDROP 2
	NIP
	RET

	.globl		get_address
	.type		get_address, @function
	;; stack=0
	PRINTSTR get_address

	PUSHCTR c7
	FIRST
	INDEX 8
	PUSHINT 11
	SDSKIPFIRST ; skip anycast: + workchain_id
	LDU 256
	DROP
	RET

	.globl		get_rand_seed
	.type		get_rand_seed, @function
	;; stack=0
	PRINTSTR get_rand_seed
	PUSH c7
	FIRST
	INDEX 6
	RET

	.globl	get_msg_pubkey
	.type	get_msg_pubkey, @function
	; s0 - msg body: slice
	; Returns 0 if message is not signed
	; Returns sender's pubkey if signature is valid
	; Throws exception 40 if signature is invalid
	DUP
	PRINTSTR get_msg_pubkey
	SREMPTY
	PUSHCONT {
		DROP
		PUSHINT 0
	}
	PUSHCONT {
		;;;; Checks the signature of a given message and returns sender's public key
		;;;; Throws exception 40 if signature is invalid

		; stack: msg
		ZERO SWAP
		; stack: 0 msg
		LDREFRTOS
		;check if it's empty
		DUP
		SDEMPTY
		PUSHCONT {
			; signature slice is empty
			; clean the stack and return 0
			BLKDROP 2
		}
		IFJMP
		; stack: 0 msg' slice:sign+pubKey
		DUP
		; stack: 0 msg' slice:sign+pubKey slice:sign+pubKey
		PUSHINT 512
		SDSKIPFIRST
		LDU 256
		DROP
		; stack: 0 msg' slice:sign+pubKey pubKey
		DUP
		; stack: 0 msg' slice:sign+pubKey pubKey pubKey
		POP s4
		; stack: pubKey msg' slice:sign+pubKey pubKey
		ROT
		; stack: pubKey slice:sign+pubKey pubKey msg'
		HASHSU
		; stack: pubKey slice:sign+pubKey pubKey msg-hash
		ROTREV
		; stack: pubKey msg-hash slice:sign+pubKey pubKey
		CHKSIGNU
		THROWIFNOT 40
		; stack: pubKey
	}
	IFELSE
	RET

	.internal   :main_external
	; s0 - msg body: slice
	; s1 - msg: cell
	; s2 - gram balance of msg: int
	; s3 - gram balance of contract: int
	PRINTSTR main_external
	PUSH s3
	PUSH s3
	; s0 - gram balance of msg: int
	; s1 - gram balance of contract: int
	; s2 - msg body: slice
	; s3 - msg: cell
	; s4 - gram balance of msg: int
	; s5 - gram balance of contract: int

	PUSH s3
	PUSHINT $get_src_addr$
	CALL 1
	POP s4
	XCHG s2, s3
	XCHG s1, s2
	XCHG s0, s1
	; s0 - addr
	; s1 - gram balance of msg: int
	; s2 - gram balance of contract: int
	; s3 - msg body: slice
	; s4 - gram balance of msg: int
	; s5 - gram balance of contract: int

	PUSH s3
	PUSHINT $get_msg_pubkey$
	CALL 1
	; s0 - pubkey
	; s1 - addr
	; s2 - gram balance of msg: int
	; s3 - gram balance of contract: int
	; s4 - msg body: slice
	; s5 - gram balance of msg: int
	; s6 - gram balance of contract: int

	PUSH s4		;push body
	DUP
	SREMPTY
	PUSHCONT {
		LDREF		;detach signature cell from body
		POP s6		;rewrite original body with remaining body slice
	}
	IFNOT
	DROP			;drop body or signature cell

	PUSHINT $store_signature$
	CALL 1
	NIP
	NIP

	; s0 - msg body: slice

	; check if message is empty
	DUP
	SDEMPTY
	PUSHCONT {
		PRINTSTR msg_is_empty
		DROP
		NEWDICT
		NEWC STDICT ENDC
		POPROOT
		RET
	}
	IFJMP

	;parse ABI version (1 byte) and load function id (4 bytes)
	LDU 8       ;load ABI version
	SWAP
	THROWIF 55  ; only version 0 is supported now
	LDU 32      ;load func id
	SWAP
	CALL 1      ;public method call


	.globl		get_src_addr
	.type		get_src_addr, @function
	; s0 - msg: cell
	PRINTSTR get_src_addr
	CTOS
	LDU 1
	SWAP
	PUSHCONT {
		DROP
		PUSHINT 0
		RET
	}
	IFJMP

	PUSHINT 3
	SDSKIPFIRST ; skip ihr_disabled + bounce + bounced

	;; here we parse src : MsgIntAddress

	PUSHINT 11
	SDSKIPFIRST ; skip anycast: + workchain_id
	LDU 256
	DROP ; drop slice itself
	RET

	.internal   :main_internal
	; s0 - msg body: slice
	; s1 - msg: cell
	; s2 - gram balance of msg: int
	; s3 - gram balance of contract: int
	PRINTSTR main_internal
	PUSH s3
	PUSH s3
	; s0 - gram balance of msg: int
	; s1 - gram balance of contract: int
	; s2 - msg body: slice
	; s3 - msg: cell
	; s4 - gram balance of msg: int
	; s5 - gram balance of contract: int

	PUSH s3
	PUSHINT $get_src_addr$
	CALL 1
	POP s4
	XCHG s2, s3
	XCHG s1, s2
	XCHG s0, s1
	; s0 - addr
	; s1 - gram balance of msg: int
	; s2 - gram balance of contract: int
	; s3 - msg body: slice
	; s4 - gram balance of msg: int
	; s5 - gram balance of contract: int

	PUSHINT 0 ; put 0 instead of signature
	; s0 - 0 as signature
	; s1 - addr
	; s2 - gram balance of msg: int
	; s3 - gram balance of contract: int
	; s4 - msg body: slice
	; s5 - gram balance of msg: int
	; s6 - gram balance of contract: int

	PUSHINT $store_signature$
	CALL 1
	NIP
	NIP

	; s0 - msg body: slice

	; protection against empty message
	DUP
	SEMPTY
	IFRET

	;parse ABI version (1 byte) and load function id (4 bytes)
	LDU 8       ;load ABI version
	SWAP
	THROWIF 55  ; only version 0 is supported now
	LDU 32      ;load func id
	SWAP
	CALL 1      ;public method call

	RET

	.globl	send_grams
	.type	send_grams, @function
		;args:
		;; s0 - body: slice
		;; s1 - dst account address: integer
		;; s2 - transfer grams value: integer
		;ret: none
		PRINTSTR send_grams
		PUSHINT 0	;; next msg logical time
		PUSH s1	;; body: slice
		PUSH s3	;; dst account address: integer
		PUSH s5	;; transfer grams value: integer
		PUSHINT $send_int_msg$
		CALL 1

		POP s1
		POP s1
		POP s1
		RET

	.globl	send_int_msg_2
	.type	send_int_msg_2, @function
		;args:
		; s0 - body: slice
		; s1 - dst account address: integer
		;ret: none

		PUSHINT 0	;; next msg logical time
		PUSH s1		;; body: slice
		PUSH s3		;; dst account address: integer
		PUSHINT 10000	;; transfer grams value: integer

		PUSHINT $send_int_msg$
		CALL 1

		DROP
		DROP
		RET

	.globl   build_external_outbound_message
	.type	 build_external_outbound_message, @function
	; build external outbound message
	; s0 - src address : MsgAddressInt
	; s1 - logical time
	; s2 - body
	; returns: msg: cell

	NEWC
	TWO
	STONES ; ext_out_msg_info$11

	STSLICE ; store MsgAddressInt

	TWO
	STZEROES ; addr_none$00

	STU 64  ; created_lt:uint64
	PUSHINT 0
	STUR 32  ; created_at:uint32

	ONE
	STZEROES   ; Maybe StateInit to 0bit

	;check that the result builder can fit
	;body slice
	DUP2
	BREMBITS
	SWAP
	SBITS
	INC         ;include body either bit
	GEQ
	PUSHCONT {
		;builder has enough free bits,
		;just append body slice to builder
		ONE
		STZEROES  ;body Either: left$0
		STSLICE
	}
	PUSHCONT {
		;builder's remaining bits are not enough
		;to append body slice, instead append bit 1
		;and attach body as reference.
		ONE
		STONES   ;body Either: right$1
		SWAP
		;body is a slice, and we need to convert
		;it to cell before storing as reference.
		NEWC
		STSLICE
		ENDC
		STREFR
	}
	IFELSE

	ENDC



	.globl   send_ext_msg
	.type    send_ext_msg, @function
	;args: s0 - body: slice
	;ret: none
	; load SmartContractInfo
	LTIME
	PUSHCTR c7
	FIRST
	INDEX 8
	; s0 - myself: MsgAddressInt (slice)
	; s1 - trans_lt: u64
	PUSHINT $build_external_outbound_message$
	CALL 1
	PUSHINT 0
	SENDRAWMSG



	.globl		get_contract_balance
	.type		get_contract_balance, @function
	;; stack=0
	PRINTSTR get_cnt_balance
	PUSHCTR c7
	FIRST
	INDEX 7
	FIRST
	RET
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;; THE CODE BELOW IS GENERATED. DO NOT CHANGE IT!

