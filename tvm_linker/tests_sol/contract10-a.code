.globl	send_uint64_external
.type	send_uint64_external, @function
LDU 256
LDU 64
DROP
PUSHINT $send_uint64$
CALL 1
RET

.globl	send_uint64
.type	send_uint64, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: send_uint64
;; param: receiver
;; param: count
;; new uint64[] memory
PUSHINT 0
NEWC STU 64 ENDC CTOS
;; count
;; stack=3
PUSH s1
DUP
PUSHCONT {
	DEC
	NEWDICT
	PUSHINT 32
	DICTUSET
	;; stack=5
}
PUSHCONT { DROP DROP NEWDICT }
IFELSE
;; decl: arr
; for statement
PUSHINT 0
;; decl: i
PUSHCONT {
	;; i
	;; stack=4
	DUP
	;; count
	;; stack=5
	PUSH s3
	;; <
	LESS
	NOT DUP IFRET DROP
	;; m_isUntil = 1
	;; fetch arr
	PUSH s1
	;; i
	;; stack=5
	PUSH s1
	SWAP
	;; i
	;; stack=6
	PUSH s2
	PUSHINT 1
	;; +
	ADD
	NEWC STU 64 ENDC CTOS
	ROTREV
	PUSHINT 32
	DICTUSET
	;; assign arr
	POP s2
	;; ++
	INC
	FALSE
}
UNTIL
; erase i
DROP
; for end
;; receiver
;; stack=3
PUSH s2
;; IReceiver
;; stack=4
;; IReceiver.on_uint64
NEWC
PUSHINT 0
STUR 8
PUSHINT $on_uint64_external$
STUR 32
;; arr
;; arr
;; stack=5
PUSH s2
PUSHINT 64
PUSHINT $encode_array$
CALL 1
ENDC CTOS
PUSHINT $send_int_msg_2$
CALL 1
;; ++
;; m_counter
;; stack=3
PUSHINT 0
PUSHROOT CTOS PLDDICT
PUSHINT 256
DICTUGET
PUSHCONT { LDU 256 ENDS }
PUSHCONT { PUSHINT 0 }
IFELSE
INC
;; assign m_counter
NEWC STU 256 ENDC CTOS
PUSHINT 0
PUSHROOT CTOS PLDDICT
PUSHINT 256
DICTUSET
NEWC STDICT ENDC
POPROOT
BLKDROP 3

.globl	send_uint64_two_external
.type	send_uint64_two_external, @function
LDU 256
LDU 64
DROP
PUSHINT $send_uint64_two$
CALL 1
RET

.globl	send_uint64_two
.type	send_uint64_two, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: send_uint64_two
;; param: receiver
;; param: count
;; new uint64[] memory
PUSHINT 0
NEWC STU 64 ENDC CTOS
;; count
;; stack=3
PUSH s1
DUP
PUSHCONT {
	DEC
	NEWDICT
	PUSHINT 32
	DICTUSET
	;; stack=5
}
PUSHCONT { DROP DROP NEWDICT }
IFELSE
;; decl: arr0
; for statement
PUSHINT 0
;; decl: i
PUSHCONT {
	;; i
	;; stack=4
	DUP
	;; count
	;; stack=5
	PUSH s3
	;; <
	LESS
	NOT DUP IFRET DROP
	;; m_isUntil = 1
	;; fetch arr0
	PUSH s1
	;; i
	;; stack=5
	PUSH s1
	SWAP
	;; i
	;; stack=6
	PUSH s2
	PUSHINT 1
	;; +
	ADD
	NEWC STU 64 ENDC CTOS
	ROTREV
	PUSHINT 32
	DICTUSET
	;; assign arr0
	POP s2
	;; ++
	INC
	FALSE
}
UNTIL
; erase i
DROP
; for end
;; new uint64[] memory
PUSHINT 0
NEWC STU 64 ENDC CTOS
;; count
;; stack=4
PUSH s2
DUP
PUSHCONT {
	DEC
	NEWDICT
	PUSHINT 32
	DICTUSET
	;; stack=6
}
PUSHCONT { DROP DROP NEWDICT }
IFELSE
;; decl: arr1
; for statement
PUSHINT 0
;; decl: i
PUSHCONT {
	;; i
	;; stack=5
	DUP
	;; count
	;; stack=6
	PUSH s4
	;; <
	LESS
	NOT DUP IFRET DROP
	;; m_isUntil = 1
	;; fetch arr1
	PUSH s1
	;; i
	;; stack=6
	PUSH s1
	SWAP
	PUSHINT 100
	;; i
	;; stack=8
	PUSH s3
	;; +
	ADD
	PUSHINT 1
	;; +
	ADD
	NEWC STU 64 ENDC CTOS
	ROTREV
	PUSHINT 32
	DICTUSET
	;; assign arr1
	POP s2
	;; ++
	INC
	FALSE
}
UNTIL
; erase i
DROP
; for end
;; receiver
;; stack=4
PUSH s3
;; IReceiver
;; stack=5
;; IReceiver.on_two_uint64
NEWC
PUSHINT 0
STUR 8
PUSHINT $on_two_uint64_external$
STUR 32
;; arr0
;; arr0
;; stack=6
PUSH s3
PUSHINT 64
PUSHINT $encode_array$
CALL 1
;; arr1
;; arr1
;; stack=6
PUSH s2
PUSHINT 64
PUSHINT $encode_array$
CALL 1
ENDC CTOS
PUSHINT $send_int_msg_2$
CALL 1
;; ++
;; m_counter
;; stack=4
PUSHINT 0
PUSHROOT CTOS PLDDICT
PUSHINT 256
DICTUGET
PUSHCONT { LDU 256 ENDS }
PUSHCONT { PUSHINT 0 }
IFELSE
INC
;; assign m_counter
NEWC STU 256 ENDC CTOS
PUSHINT 0
PUSHROOT CTOS PLDDICT
PUSHINT 256
DICTUSET
NEWC STDICT ENDC
POPROOT
BLKDROP 4

.globl	on_two_uint64_external
.type	on_two_uint64_external, @function
RET

.globl	on_uint64_external
.type	on_uint64_external, @function
RET

